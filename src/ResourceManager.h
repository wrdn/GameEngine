#pragma once

#include "util.h"
#include <map>
#include <memory>
#include "Resource.h"
using namespace std;

// Resource manager used to manager game resources (e.g. textures, audio)
// Returns an id to the resource, then use GetResource(id) to get the actual shared
// pointer to it. Anything inheriting from Resource can be managed by this
// To skip retrieving the ID first, call CreateAndGetResource(). All created resources
// contain their associated ID, so you can easily call GetID() on it
class ResourceManager
{
private:
	// maps resource id (generated by hashing string, see HashResourceString function) to the Resource itself
	// Pointers used to allow objects inheriting Resource to use same structure
	map<i32, ResourceHandle> resourceMap;

	// singleton, all accesses through this (using get() function)
	static ResourceManager *resMan;
	static i32 idProvider; // if user doesn't provide a name for the resource, we create the ID by incrementing this value

	// constructor and destructor private so only 1 instance can exist (resMan singleton)
	ResourceManager() {};
	~ResourceManager() { delete resMan; };

	void AddResource(i32 id, const char *name, Resource *r);

public:
	// get the resource manager singleton
	static ResourceManager& get();

	// gets resource ID using string hashing given name (str)
	static i32 GetResourceID(const char *str) { return (i32)hash_djb2((const uc8*)str); };

	template<class T>
	i32 CreateResource()
	{
		while(resourceMap.count(idProvider)) ++idProvider; // find ID space
		AddResource(idProvider, 0, new T());
		return idProvider;
	};

	template<class T>
	i32 CreateResource(char *resourceName) // creates a new resource using hashed resourceName, or returns the ID of the resource if it already exists
	{
		i32 resHash = GetResourceID(resourceName);
		if(resourceMap.count(resHash)) { return resHash; };

		AddResource(resHash, resourceName, new T());
		return resHash;
	};

	template<class T>
	i32 LoadResource(const char *resourceName, const char *filename)
	{
		i32 resHash = GetResourceID(resourceName);
		if(resourceMap.count(resHash)) { return resHash; };

		T *t = new T();
		if( ! ((Resource*)t)->Load(filename) )
		{
			delete t;
			return -1;
		}

		AddResource(resHash, resourceName, t);
		return resHash;
	};

	template<class T>
	i32 LoadResource(const char *filename)
	{
		return LoadResource<T>(filename, filename);
	};

	template<class T>
	shared_ptr<T> GetResource(i32 id)
	{
		if(resourceMap.count(id))
		{
			return std::static_pointer_cast<T>(resourceMap[id]);
		}
		return shared_ptr<T>(0);
	};

	// Preferred functions, built out of CreateResource() and GetResource()
	template<class T>
	shared_ptr<T> CreateAndGetResource() { return GetResource<T>(CreateResource<T>()); };
	
	template<class T>
	shared_ptr<T> CreateAndGetResource(char *resourceName) { return GetResource<T>(CreateResource<T>(resourceName)); };

	template<class T>
	shared_ptr<T> LoadAndGetResource(char *resourceName, char *filename) { return GetResource<T>(LoadResource<T>(resourceName, filename)); };

	template<class T>
	shared_ptr<T> LoadAndGetResource(char *filename) { return GetResource<T>(LoadResource<T>(filename)); };
};